// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
    baseURL: 'https://www.aptly.info' | (string & {});
};

export type ApiError = {
    error?: string;
};

export type ApiAptlyStatus = {
    /**
     * Aptly Status
     */
    Status?: string;
};

export type ApiAptlyVersion = {
    /**
     * Aptly Version
     */
    Version?: string;
};

export type ApiDiskFree = {
    /**
     * Available Storage [MiB]
     */
    free?: number;
    /**
     * Percentage Full
     */
    percentFull?: number;
    /**
     * Storage size [MiB]
     */
    total?: number;
};

export type ApiGpgAddKeyParams = {
    /**
     * Add ASCII armored gpg public key, do not download from keyserver
     */
    GpgKeyArmor?: string;
    /**
     * Keys do download from `Keyserver`, separated by space
     */
    GpgKeyID?: string;
    /**
     * Keyring for adding the keys (default: trustedkeys.gpg)
     */
    Keyring?: string;
    /**
     * Keyserver to download keys provided in `GpgKeyID`
     */
    Keyserver?: string;
};

export type ApiMirrorCreateParams = {
    /**
     * Limit mirror to those architectures, if not specified aptly would fetch all architectures
     */
    Architectures?: Array<string>;
    /**
     * Url of the archive to mirror
     */
    ArchiveURL: string;
    /**
     * Components to mirror, if not specified aptly would fetch all components
     */
    Components?: Array<string>;
    /**
     * Distribution name to mirror
     */
    Distribution?: string;
    /**
     * Set "true" to mirror installer files
     */
    DownloadInstaller?: boolean;
    /**
     * Set "true" to mirror source packages
     */
    DownloadSources?: boolean;
    /**
     * Set "true" to mirror udeb files
     */
    DownloadUdebs?: boolean;
    /**
     * Package query that is applied to mirror packages
     */
    Filter?: string;
    /**
     * Set "true" to include dependencies of matching packages when filtering
     */
    FilterWithDeps?: boolean;
    /**
     * Set "true" to skip the verification of Release file signatures
     */
    IgnoreSignatures?: boolean;
    /**
     * Gpg keyring(s) for verifying Release file
     */
    Keyrings?: Array<string>;
    /**
     * Name of mirror to be created
     */
    Name: string;
    /**
     * Set "true" to skip the verification of architectures
     */
    SkipArchitectureCheck?: boolean;
    /**
     * Set "true" to skip if the given components are in the Release file
     */
    SkipComponentCheck?: boolean;
};

export type ApiMirrorUpdateParams = {
    /**
     * Limit mirror to those architectures, if not specified aptly would fetch all architectures
     */
    Architectures?: Array<string>;
    /**
     * Url of the archive to mirror
     */
    ArchiveURL?: string;
    /**
     * Components to mirror, if not specified aptly would fetch all components
     */
    Components?: Array<string>;
    /**
     * Set "true" to mirror source packages
     */
    DownloadSources?: boolean;
    /**
     * Set "true" to mirror udeb files
     */
    DownloadUdebs?: boolean;
    /**
     * Package query that is applied to mirror packages
     */
    Filter?: string;
    /**
     * Set "true" to include dependencies of matching packages when filtering
     */
    FilterWithDeps?: boolean;
    /**
     * Set "true" to force a mirror update even if another process is already updating the mirror (use with caution!)
     */
    ForceUpdate?: boolean;
    /**
     * Set "true" to ignore checksum errors
     */
    IgnoreChecksums?: boolean;
    /**
     * Set "true" to skip the verification of Release file signatures
     */
    IgnoreSignatures?: boolean;
    /**
     * Gpg keyring(s) for verifing Release file
     */
    Keyrings?: Array<string>;
    /**
     * Change mirror name to `Name`
     */
    Name?: string;
    /**
     * Set "true" to skip checking if the given architectures are in the Release file
     */
    SkipArchitectureCheck?: boolean;
    /**
     * Set "true" to skip checking if the given components are in the Release file
     */
    SkipComponentCheck?: boolean;
    /**
     * Set "true" to skip downloading already downloaded packages
     */
    SkipExistingPackages?: boolean;
};

export type ApiPublishedRepoCreateParams = {
    /**
     * Provide index files by hash
     */
    AcquireByHash?: boolean;
    /**
     * Override list of published architectures
     */
    Architectures?: Array<string>;
    /**
     * setting to yes excludes upgrades from the NotAutomic setting
     */
    ButAutomaticUpgrades?: string;
    /**
     * Distribution name, if missing Aptly would try to guess from sources
     */
    Distribution?: string;
    /**
     * when publishing, overwrite files in pool/ directory without notice
     */
    ForceOverwrite?: boolean;
    /**
     * Value of Label: field in published repository stanza
     */
    Label?: string;
    /**
     * Enable multiple packages with the same filename in different distributions
     */
    MultiDist?: boolean;
    /**
     * Setting to yes indicates to the package manager to not install or upgrade packages from the repository without user consent
     */
    NotAutomatic?: string;
    /**
     * Value of Origin: field in published repository stanza
     */
    Origin?: string;
    /**
     * GPG options
     */
    Signing?: ApiSigningParams;
    /**
     * Skip bz2 compression for index files
     */
    SkipBz2?: boolean;
    /**
     * Don't remove unreferenced files in prefix/component
     */
    SkipCleanup?: boolean;
    /**
     * Don't generate contents indexes
     */
    SkipContents?: boolean;
    /**
     * 'local' for local repositories and 'snapshot' for snapshots
     */
    SourceKind: string;
    /**
     * List of 'Component/Name' objects, 'Name' is either local repository or snapshot name
     */
    Sources: Array<ApiSourceParams>;
};

export type ApiPublishedRepoUpdateParams = {
    /**
     * Provide index files by hash
     */
    AcquireByHash?: boolean;
    /**
     * when publishing, overwrite files in pool/ directory without notice
     */
    ForceOverwrite?: boolean;
    /**
     * Enable multiple packages with the same filename in different distributions
     */
    MultiDist?: boolean;
    /**
     * GPG options
     */
    Signing?: ApiSigningParams;
    /**
     * Skip bz2 compression for index files
     */
    SkipBz2?: boolean;
    /**
     * Don't remove unreferenced files in prefix/component
     */
    SkipCleanup?: boolean;
    /**
     * Don't generate contents indexes
     */
    SkipContents?: boolean;
};

export type ApiPublishedRepoUpdateSwitchParams = {
    /**
     * Provide index files by hash
     */
    AcquireByHash?: boolean;
    /**
     * when publishing, overwrite files in pool/ directory without notice
     */
    ForceOverwrite?: boolean;
    /**
     * Enable multiple packages with the same filename in different distributions
     */
    MultiDist?: boolean;
    /**
     * GPG options
     */
    Signing?: ApiSigningParams;
    /**
     * Skip bz2 compression for index files
     */
    SkipBz2?: boolean;
    /**
     * Don't remove unreferenced files in prefix/component
     */
    SkipCleanup?: boolean;
    /**
     * Don't generate contents indexes
     */
    SkipContents?: boolean;
    /**
     * only when updating published snapshots, list of objects 'Component/Name'
     */
    Snapshots?: Array<ApiSourceParams>;
};

export type ApiRepoCreateParams = {
    /**
     * Text describing the repository (optional)
     */
    Comment?: string;
    /**
     * Default component when publishing from this local repo
     */
    DefaultComponent?: string;
    /**
     * Default distribution when publishing from this local repo
     */
    DefaultDistribution?: string;
    /**
     * Snapshot name to create repoitory from (optional)
     */
    FromSnapshot?: string;
    /**
     * Name of repository to create
     */
    Name: string;
};

export type ApiReposEditParams = {
    /**
     * Change Comment of repository
     */
    Comment?: string;
    /**
     * Change Devault Component for publishing
     */
    DefaultComponent?: string;
    /**
     * Change Default Distribution for publishing
     */
    DefaultDistribution?: string;
    /**
     * Name of repository to modify
     */
    Name: string;
};

export type ApiReposIncludePackageFromDirResponse = {
    failedFiles?: Array<string>;
    report?: AptlyRecordingResultReporter;
};

export type ApiReposPackagesAddDeleteParams = {
    /**
     * Package Refs
     */
    PackageRefs: Array<string>;
};

export type ApiSigningParams = {
    /**
     * GPG key ID to use when signing the release, if not specified default key is used
     */
    GpgKey?: string;
    /**
     * GPG keyring to use (instead of default)
     */
    Keyring?: string;
    /**
     * GPG passphrase to unlock private key (possibly insecure)
     */
    Passphrase?: string;
    /**
     * GPG passphrase file to unlock private key (possibly insecure)
     */
    PassphraseFile?: string;
    /**
     * GPG secret keyring to use (instead of default) Note: depreciated with gpg2
     */
    SecretKeyring?: string;
    /**
     * Don't sign published repository
     */
    Skip?: boolean;
};

export type ApiSnapshotsCreateFromMirrorParams = {
    /**
     * Description of snapshot
     */
    Description?: string;
    /**
     * Name of snapshot to create
     */
    Name: string;
};

export type ApiSnapshotsCreateFromRepositoryParams = {
    /**
     * Description of snapshot
     */
    Description?: string;
    /**
     * Name of snapshot to create
     */
    Name: string;
};

export type ApiSnapshotsCreateParams = {
    /**
     * Description of snapshot
     */
    Description?: string;
    /**
     * Name of snapshot to create
     */
    Name: string;
    /**
     * List of package refs
     */
    PackageRefs?: Array<string>;
    /**
     * List of source snapshots
     */
    SourceSnapshots?: Array<string>;
};

export type ApiSnapshotsMergeParams = {
    /**
     * List of snapshot names to be merged
     */
    Sources: Array<string>;
};

export type ApiSnapshotsPullParams = {
    /**
     * List of architectures (optional)
     */
    Architectures?: Array<string>;
    /**
     * Name of the snapshot to be created
     */
    Destination: string;
    /**
     * List of package queries (i.e. name of package to be pulled from `Source`)
     */
    Queries: Array<string>;
    /**
     * Source name to be searched for packages and dependencies
     */
    Source: string;
};

export type ApiSnapshotsUpdateParams = {
    /**
     * Change Description of snapshot
     */
    Description?: string;
    /**
     * Change Name of snapshot
     */
    Name?: string;
};

export type ApiSourceParams = {
    /**
     * Name of the component
     */
    Component: string;
    /**
     * Name of the local repository/snapshot
     */
    Name: string;
};

export type AptlyRecordingResultReporter = {
    Added?: Array<string>;
    Removed?: Array<string>;
    warnings?: Array<string>;
};

export type DebLocalRepo = {
    /**
     * Comment
     */
    comment?: string;
    /**
     * DefaultComponent
     */
    defaultComponent?: string;
    /**
     * DefaultDistribution
     */
    defaultDistribution?: string;
    /**
     * User-assigned name
     */
    name?: string;
};

export type DebPackage = {
    architecture?: string;
    /**
     * Hash of files section
     */
    filesHash?: number;
    /**
     * Is this package a dummy installer package
     */
    isInstaller?: boolean;
    /**
     * Is this source package
     */
    isSource?: boolean;
    /**
     * Is this udeb package
     */
    isUdeb?: boolean;
    /**
     * Basic package properties
     */
    name?: string;
    /**
     * List of virtual packages this package provides
     */
    provides?: Array<string>;
    /**
     * For binary package, name of source package
     */
    source?: string;
    /**
     * If this source package, this field holds "real" architecture value,
     * while Architecture would be equal to "source"
     */
    sourceArchitecture?: string;
    /**
     * Is this >= 0.6 package?
     */
    v06Plus?: boolean;
    version?: string;
};

export type DebPackageDiff = {
    left?: DebPackage;
    right?: DebPackage;
};

export type DebPublishedRepo = {
    /**
     * Provide index files per hash also
     */
    acquireByHash?: boolean;
    /**
     * Architectures is a list of all architectures published
     */
    architectures?: Array<string>;
    butAutomaticUpgrades?: string;
    codename?: string;
    /**
     * Legacy fields for compatibility with old published repositories (< 0.6)
     */
    component?: string;
    distribution?: string;
    label?: string;
    /**
     * Support multiple distributions
     */
    multiDist?: boolean;
    notAutomatic?: string;
    origin?: string;
    prefix?: string;
    /**
     * Revision
     */
    revision?: DebPublishedRepoRevision;
    /**
     * Skip bz2 compression for index files
     */
    skipBz2?: boolean;
    /**
     * Skip contents generation
     */
    skipContents?: boolean;
    /**
     * SourceKind is "local"/"repo"
     */
    sourceKind?: string;
    /**
     * SourceUUID is UUID of either snapshot or local repo
     */
    sourceUUID?: string;
    /**
     * Map of sources by each component: component name -> source UUID
     */
    sources?: {
        [key: string]: string;
    };
    /**
     * Storage & Prefix & distribution should be unique across all published repositories
     */
    storage?: string;
    suite?: string;
    /**
     * Internal unique ID
     */
    uuid?: string;
};

export type DebPublishedRepoRevision = {
    /**
     * Map of sources: component name -> snapshot name/local repo Name
     */
    sources?: {
        [key: string]: string;
    };
};

export type DebRemoteRepo = {
    /**
     * List of architectures to fetch, if empty, then fetch all architectures
     */
    architectures?: Array<string>;
    /**
     * Root of Debian archive, URL
     */
    archiveRoot?: string;
    /**
     * List of components to fetch, if empty, then fetch all components
     */
    components?: Array<string>;
    /**
     * Distribution name, e.g. squeeze
     */
    distribution?: string;
    /**
     * Should we download installer files?
     */
    downloadInstaller?: boolean;
    /**
     * Should we download sources?
     */
    downloadSources?: boolean;
    /**
     * Should we download .udebs?
     */
    downloadUdebs?: boolean;
    /**
     * Filter for packages
     */
    filter?: string;
    /**
     * FilterWithDeps to include dependencies from filter query
     */
    filterWithDeps?: boolean;
    /**
     * Last update date
     */
    lastDownloadDate?: string;
    /**
     * Meta-information about repository
     */
    meta?: DebStanza;
    /**
     * User-assigned name
     */
    name?: string;
    /**
     * Packages for json output
     */
    packages?: Array<string>;
    /**
     * SkipArchitectureCheck skips architecture list verification
     */
    skipArchitectureCheck?: boolean;
    /**
     * SkipComponentCheck skips component list verification
     */
    skipComponentCheck?: boolean;
    /**
     * Status marks state of repository (being updated, no action)
     */
    status?: number;
    /**
     * Permanent internal ID
     */
    uuid?: string;
    /**
     * WorkerPID is PID of the process modifying the mirror (if any)
     */
    workerPID?: number;
};

export type DebSnapshot = {
    butAutomaticUpgrades?: string;
    /**
     * Date of creation
     */
    createdAt?: string;
    /**
     * Description of how snapshot was created
     */
    description?: string;
    localRepos?: Array<DebLocalRepo>;
    /**
     * Human-readable name
     */
    name?: string;
    notAutomatic?: string;
    origin?: string;
    packages?: Array<string>;
    remoteRepos?: Array<DebRemoteRepo>;
    /**
     * Sources
     */
    snapshots?: Array<DebSnapshot>;
    /**
     * Source: kind + ID
     */
    sourceKind?: string;
};

export type DebSourceEntry = {
    component?: string;
    name?: string;
};

export type DebStanza = {
    [key: string]: string;
};

export type TaskProcessReturnValue = {
    code?: number;
    value?: unknown;
};

export type TaskState = 0 | 1 | 2 | 3;

export type TaskTask = {
    id?: number;
    name?: string;
    state?: TaskState;
};

export type PostApiDbCleanupData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Run in background and return task object
         */
        _async?: boolean;
    };
    url: '/api/db/cleanup';
};

export type PostApiDbCleanupErrors = {
    /**
     * Not Found
     */
    404: ApiError;
};

export type PostApiDbCleanupError = PostApiDbCleanupErrors[keyof PostApiDbCleanupErrors];

export type PostApiDbCleanupResponses = {
    /**
     * Output
     */
    200: string;
};

export type PostApiDbCleanupResponse = PostApiDbCleanupResponses[keyof PostApiDbCleanupResponses];

export type GetApiFilesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/files';
};

export type GetApiFilesResponses = {
    /**
     * List of files
     */
    200: Array<string>;
};

export type GetApiFilesResponse = GetApiFilesResponses[keyof GetApiFilesResponses];

export type DeleteApiFilesByDirData = {
    body?: never;
    path: {
        /**
         * Directory
         */
        dir: string;
    };
    query?: never;
    url: '/api/files/{dir}';
};

export type DeleteApiFilesByDirErrors = {
    /**
     * Internal Server Error
     */
    500: ApiError;
};

export type DeleteApiFilesByDirError = DeleteApiFilesByDirErrors[keyof DeleteApiFilesByDirErrors];

export type DeleteApiFilesByDirResponses = {
    /**
     * msg
     */
    200: string;
};

export type DeleteApiFilesByDirResponse = DeleteApiFilesByDirResponses[keyof DeleteApiFilesByDirResponses];

export type GetApiFilesByDirData = {
    body?: never;
    path: {
        /**
         * Directory to list
         */
        dir: string;
    };
    query?: never;
    url: '/api/files/{dir}';
};

export type GetApiFilesByDirErrors = {
    /**
     * Not Found
     */
    404: ApiError;
    /**
     * Internal Server Error
     */
    500: ApiError;
};

export type GetApiFilesByDirError = GetApiFilesByDirErrors[keyof GetApiFilesByDirErrors];

export type GetApiFilesByDirResponses = {
    /**
     * Files found in directory
     */
    200: Array<string>;
};

export type GetApiFilesByDirResponse = GetApiFilesByDirResponses[keyof GetApiFilesByDirResponses];

export type PostApiFilesByDirData = {
    body: {
        /**
         * Files to upload
         */
        files: Blob | File;
    };
    path: {
        /**
         * Directory to upload files to. Created if does not exist
         */
        dir: string;
    };
    query?: never;
    url: '/api/files/{dir}';
};

export type PostApiFilesByDirErrors = {
    /**
     * Bad Request
     */
    400: ApiError;
    /**
     * Not Found
     */
    404: ApiError;
    /**
     * Internal Server Error
     */
    500: ApiError;
};

export type PostApiFilesByDirError = PostApiFilesByDirErrors[keyof PostApiFilesByDirErrors];

export type PostApiFilesByDirResponses = {
    /**
     * list of uploaded files
     */
    200: Array<string>;
};

export type PostApiFilesByDirResponse = PostApiFilesByDirResponses[keyof PostApiFilesByDirResponses];

export type DeleteApiFilesByDirByNameData = {
    body?: never;
    path: {
        /**
         * Directory to delete from
         */
        dir: string;
        /**
         * File to delete
         */
        name: string;
    };
    query?: never;
    url: '/api/files/{dir}/{name}';
};

export type DeleteApiFilesByDirByNameErrors = {
    /**
     * Bad Request
     */
    400: ApiError;
    /**
     * Internal Server Error
     */
    500: ApiError;
};

export type DeleteApiFilesByDirByNameError = DeleteApiFilesByDirByNameErrors[keyof DeleteApiFilesByDirByNameErrors];

export type DeleteApiFilesByDirByNameResponses = {
    /**
     * msg
     */
    200: string;
};

export type DeleteApiFilesByDirByNameResponse = DeleteApiFilesByDirByNameResponses[keyof DeleteApiFilesByDirByNameResponses];

export type PostApiGpgKeyData = {
    /**
     * Parameters
     */
    body: ApiGpgAddKeyParams;
    path?: never;
    query?: never;
    url: '/api/gpg/key';
};

export type PostApiGpgKeyErrors = {
    /**
     * Bad Request
     */
    400: ApiError;
};

export type PostApiGpgKeyError = PostApiGpgKeyErrors[keyof PostApiGpgKeyErrors];

export type PostApiGpgKeyResponses = {
    /**
     * OK
     */
    200: string;
};

export type PostApiGpgKeyResponse = PostApiGpgKeyResponses[keyof PostApiGpgKeyResponses];

export type GetApiGraphByExtData = {
    body?: never;
    path: {
        /**
         * ext specifies desired file extension, e.g. .png, .svg.
         */
        ext: string;
    };
    query?: {
        /**
         * Change between a `horizontal` (default) and a `vertical` graph layout.
         */
        layout?: string;
    };
    url: '/api/graph.{ext}';
};

export type GetApiGraphByExtErrors = {
    /**
     * Not Found
     */
    404: ApiError;
    /**
     * Internal Server Error
     */
    500: ApiError;
};

export type GetApiGraphByExtError = GetApiGraphByExtErrors[keyof GetApiGraphByExtErrors];

export type GetApiGraphByExtResponses = {
    /**
     * Output
     */
    200: Array<number>;
};

export type GetApiGraphByExtResponse = GetApiGraphByExtResponses[keyof GetApiGraphByExtResponses];

export type GetApiHealthyData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/healthy';
};

export type GetApiHealthyResponses = {
    /**
     * OK
     */
    200: ApiAptlyStatus;
};

export type GetApiHealthyResponse = GetApiHealthyResponses[keyof GetApiHealthyResponses];

export type GetApiMirrorsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/mirrors';
};

export type GetApiMirrorsResponses = {
    /**
     * OK
     */
    200: Array<DebRemoteRepo>;
};

export type GetApiMirrorsResponse = GetApiMirrorsResponses[keyof GetApiMirrorsResponses];

export type PostApiMirrorsData = {
    /**
     * Parameters
     */
    body: ApiMirrorCreateParams;
    path?: never;
    query?: never;
    url: '/api/mirrors';
};

export type PostApiMirrorsErrors = {
    /**
     * Bad Request
     */
    400: ApiError;
};

export type PostApiMirrorsError = PostApiMirrorsErrors[keyof PostApiMirrorsErrors];

export type PostApiMirrorsResponses = {
    /**
     * OK
     */
    200: DebRemoteRepo;
};

export type PostApiMirrorsResponse = PostApiMirrorsResponses[keyof PostApiMirrorsResponses];

export type DeleteApiMirrorsByNameData = {
    body?: never;
    path: {
        /**
         * mirror name
         */
        name: string;
    };
    query: {
        /**
         * force: 1 to enable
         */
        force: number;
        /**
         * Run in background and return task object
         */
        _async?: boolean;
    };
    url: '/api/mirrors/{name}';
};

export type DeleteApiMirrorsByNameErrors = {
    /**
     * Unable to delete mirror with snapshots
     */
    403: ApiError;
    /**
     * Mirror not found
     */
    404: ApiError;
    /**
     * Unable to delete
     */
    500: ApiError;
};

export type DeleteApiMirrorsByNameError = DeleteApiMirrorsByNameErrors[keyof DeleteApiMirrorsByNameErrors];

export type DeleteApiMirrorsByNameResponses = {
    /**
     * OK
     */
    200: TaskProcessReturnValue;
};

export type DeleteApiMirrorsByNameResponse = DeleteApiMirrorsByNameResponses[keyof DeleteApiMirrorsByNameResponses];

export type GetApiMirrorsByNameData = {
    body?: never;
    path: {
        /**
         * mirror name
         */
        name: string;
    };
    query?: never;
    url: '/api/mirrors/{name}';
};

export type GetApiMirrorsByNameErrors = {
    /**
     * Mirror not found
     */
    404: ApiError;
    /**
     * Internal Error
     */
    500: ApiError;
};

export type GetApiMirrorsByNameError = GetApiMirrorsByNameErrors[keyof GetApiMirrorsByNameErrors];

export type GetApiMirrorsByNameResponses = {
    /**
     * OK
     */
    200: DebRemoteRepo;
};

export type GetApiMirrorsByNameResponse = GetApiMirrorsByNameResponses[keyof GetApiMirrorsByNameResponses];

export type PutApiMirrorsByNameData = {
    /**
     * Parameters
     */
    body: ApiMirrorUpdateParams;
    path: {
        /**
         * mirror name to update
         */
        name: string;
    };
    query?: {
        /**
         * Run in background and return task object
         */
        _async?: boolean;
    };
    url: '/api/mirrors/{name}';
};

export type PutApiMirrorsByNameErrors = {
    /**
     * Unable to determine list of architectures
     */
    400: ApiError;
    /**
     * Mirror not found
     */
    404: ApiError;
    /**
     * Internal Error
     */
    500: ApiError;
};

export type PutApiMirrorsByNameError = PutApiMirrorsByNameErrors[keyof PutApiMirrorsByNameErrors];

export type PutApiMirrorsByNameResponses = {
    /**
     * Mirror was updated successfully
     */
    200: TaskProcessReturnValue;
    /**
     * Mirror is being updated
     */
    202: TaskTask;
};

export type PutApiMirrorsByNameResponse = PutApiMirrorsByNameResponses[keyof PutApiMirrorsByNameResponses];

export type GetApiMirrorsByNamePackagesData = {
    body?: never;
    path: {
        /**
         * mirror name
         */
        name: string;
    };
    query?: {
        /**
         * search query
         */
        q?: string;
        /**
         * format: `details` for more detailed information
         */
        format?: string;
    };
    url: '/api/mirrors/{name}/packages';
};

export type GetApiMirrorsByNamePackagesErrors = {
    /**
     * Unable to determine list of architectures
     */
    400: ApiError;
    /**
     * Mirror not found
     */
    404: ApiError;
    /**
     * Internal Error
     */
    500: ApiError;
};

export type GetApiMirrorsByNamePackagesError = GetApiMirrorsByNamePackagesErrors[keyof GetApiMirrorsByNamePackagesErrors];

export type GetApiMirrorsByNamePackagesResponses = {
    /**
     * List of Packages
     */
    200: Array<DebPackage>;
};

export type GetApiMirrorsByNamePackagesResponse = GetApiMirrorsByNamePackagesResponses[keyof GetApiMirrorsByNamePackagesResponses];

export type PostApiMirrorsByNameSnapshotsData = {
    /**
     * Parameters
     */
    body: ApiSnapshotsCreateFromMirrorParams;
    path: {
        /**
         * Mirror name
         */
        name: string;
    };
    query?: {
        /**
         * Run in background and return task object
         */
        _async?: boolean;
    };
    url: '/api/mirrors/{name}/snapshots';
};

export type PostApiMirrorsByNameSnapshotsErrors = {
    /**
     * Bad Request
     */
    400: ApiError;
    /**
     * Mirror Not Found
     */
    404: ApiError;
    /**
     * Conflicting snapshot
     */
    409: ApiError;
    /**
     * Internal Server Error
     */
    500: ApiError;
};

export type PostApiMirrorsByNameSnapshotsError = PostApiMirrorsByNameSnapshotsErrors[keyof PostApiMirrorsByNameSnapshotsErrors];

export type PostApiMirrorsByNameSnapshotsResponses = {
    /**
     * Created Snapshot
     */
    201: DebSnapshot;
};

export type PostApiMirrorsByNameSnapshotsResponse = PostApiMirrorsByNameSnapshotsResponses[keyof PostApiMirrorsByNameSnapshotsResponses];

export type GetApiPackagesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * search query
         */
        q?: string;
        /**
         * format: `details` for more detailed information
         */
        format?: string;
    };
    url: '/api/packages';
};

export type GetApiPackagesResponses = {
    /**
     * List of packages
     */
    200: Array<string>;
};

export type GetApiPackagesResponse = GetApiPackagesResponses[keyof GetApiPackagesResponses];

export type GetApiPackagesByKeyData = {
    body?: never;
    path: {
        /**
         * package key (unique package identifier)
         */
        key: string;
    };
    query?: never;
    url: '/api/packages/{key}';
};

export type GetApiPackagesByKeyErrors = {
    /**
     * Not Found
     */
    404: ApiError;
};

export type GetApiPackagesByKeyError = GetApiPackagesByKeyErrors[keyof GetApiPackagesByKeyErrors];

export type GetApiPackagesByKeyResponses = {
    /**
     * OK
     */
    200: DebPackage;
};

export type GetApiPackagesByKeyResponse = GetApiPackagesByKeyResponses[keyof GetApiPackagesByKeyResponses];

export type GetApiPublishData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/publish';
};

export type GetApiPublishErrors = {
    /**
     * Internal Error
     */
    500: ApiError;
};

export type GetApiPublishError = GetApiPublishErrors[keyof GetApiPublishErrors];

export type GetApiPublishResponses = {
    /**
     * OK
     */
    200: Array<DebPublishedRepo>;
};

export type GetApiPublishResponse = GetApiPublishResponses[keyof GetApiPublishResponses];

export type PostApiPublishByPrefixData = {
    /**
     * Parameters
     */
    body: ApiPublishedRepoCreateParams;
    path: {
        /**
         * publishing prefix
         */
        prefix: string;
    };
    query?: {
        /**
         * Run in background and return task object
         */
        _async?: boolean;
    };
    url: '/api/publish/{prefix}';
};

export type PostApiPublishByPrefixErrors = {
    /**
     * Bad Request
     */
    400: ApiError;
    /**
     * Source not found
     */
    404: ApiError;
    /**
     * Internal Error
     */
    500: ApiError;
};

export type PostApiPublishByPrefixError = PostApiPublishByPrefixErrors[keyof PostApiPublishByPrefixErrors];

export type PostApiPublishByPrefixResponses = {
    /**
     * Created
     */
    201: DebPublishedRepo;
};

export type PostApiPublishByPrefixResponse = PostApiPublishByPrefixResponses[keyof PostApiPublishByPrefixResponses];

export type DeleteApiPublishByPrefixByDistributionData = {
    body?: never;
    path: {
        /**
         * publishing prefix
         */
        prefix: string;
        /**
         * distribution name
         */
        distribution: string;
    };
    query: {
        /**
         * force: 1 to enable
         */
        force: number;
        /**
         * skipCleanup: 1 to enable
         */
        skipCleanup: number;
        /**
         * Run in background and return task object
         */
        _async?: boolean;
    };
    url: '/api/publish/{prefix}/{distribution}';
};

export type DeleteApiPublishByPrefixByDistributionErrors = {
    /**
     * Bad Request
     */
    400: ApiError;
    /**
     * Published repository not found
     */
    404: ApiError;
    /**
     * Internal Error
     */
    500: ApiError;
};

export type DeleteApiPublishByPrefixByDistributionError = DeleteApiPublishByPrefixByDistributionErrors[keyof DeleteApiPublishByPrefixByDistributionErrors];

export type DeleteApiPublishByPrefixByDistributionResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type GetApiPublishByPrefixByDistributionData = {
    body?: never;
    path: {
        /**
         * publishing prefix, use `:.` instead of `.` because it is ambigious in URLs
         */
        prefix: string;
        /**
         * distribution name
         */
        distribution: string;
    };
    query?: never;
    url: '/api/publish/{prefix}/{distribution}';
};

export type GetApiPublishByPrefixByDistributionErrors = {
    /**
     * Published repository not found
     */
    404: ApiError;
    /**
     * Internal Error
     */
    500: ApiError;
};

export type GetApiPublishByPrefixByDistributionError = GetApiPublishByPrefixByDistributionErrors[keyof GetApiPublishByPrefixByDistributionErrors];

export type GetApiPublishByPrefixByDistributionResponses = {
    /**
     * OK
     */
    200: DebPublishedRepo;
};

export type GetApiPublishByPrefixByDistributionResponse = GetApiPublishByPrefixByDistributionResponses[keyof GetApiPublishByPrefixByDistributionResponses];

export type PutApiPublishByPrefixByDistributionData = {
    /**
     * Parameters
     */
    body: ApiPublishedRepoUpdateSwitchParams;
    path: {
        /**
         * publishing prefix
         */
        prefix: string;
        /**
         * distribution name
         */
        distribution: string;
    };
    query?: {
        /**
         * Run in background and return task object
         */
        _async?: boolean;
    };
    url: '/api/publish/{prefix}/{distribution}';
};

export type PutApiPublishByPrefixByDistributionErrors = {
    /**
     * Bad Request
     */
    400: ApiError;
    /**
     * Published repository or source not found
     */
    404: ApiError;
    /**
     * Internal Error
     */
    500: ApiError;
};

export type PutApiPublishByPrefixByDistributionError = PutApiPublishByPrefixByDistributionErrors[keyof PutApiPublishByPrefixByDistributionErrors];

export type PutApiPublishByPrefixByDistributionResponses = {
    /**
     * OK
     */
    200: DebPublishedRepo;
};

export type PutApiPublishByPrefixByDistributionResponse = PutApiPublishByPrefixByDistributionResponses[keyof PutApiPublishByPrefixByDistributionResponses];

export type DeleteApiPublishByPrefixByDistributionSourcesData = {
    body?: never;
    path: {
        /**
         * publishing prefix
         */
        prefix: string;
        /**
         * distribution name
         */
        distribution: string;
    };
    query?: {
        /**
         * Run in background and return task object
         */
        _async?: boolean;
    };
    url: '/api/publish/{prefix}/{distribution}/sources';
};

export type DeleteApiPublishByPrefixByDistributionSourcesErrors = {
    /**
     * Bad Request
     */
    400: ApiError;
    /**
     * Published repository not found
     */
    404: ApiError;
    /**
     * Internal Error
     */
    500: ApiError;
};

export type DeleteApiPublishByPrefixByDistributionSourcesError = DeleteApiPublishByPrefixByDistributionSourcesErrors[keyof DeleteApiPublishByPrefixByDistributionSourcesErrors];

export type DeleteApiPublishByPrefixByDistributionSourcesResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type GetApiPublishByPrefixByDistributionSourcesData = {
    body?: never;
    path: {
        /**
         * publishing prefix
         */
        prefix: string;
        /**
         * distribution name
         */
        distribution: string;
    };
    query?: never;
    url: '/api/publish/{prefix}/{distribution}/sources';
};

export type GetApiPublishByPrefixByDistributionSourcesErrors = {
    /**
     * Bad Request
     */
    400: ApiError;
    /**
     * Published repository pending changes not found
     */
    404: ApiError;
    /**
     * Internal Error
     */
    500: ApiError;
};

export type GetApiPublishByPrefixByDistributionSourcesError = GetApiPublishByPrefixByDistributionSourcesErrors[keyof GetApiPublishByPrefixByDistributionSourcesErrors];

export type GetApiPublishByPrefixByDistributionSourcesResponses = {
    /**
     * OK
     */
    200: Array<Array<DebSourceEntry>>;
};

export type GetApiPublishByPrefixByDistributionSourcesResponse = GetApiPublishByPrefixByDistributionSourcesResponses[keyof GetApiPublishByPrefixByDistributionSourcesResponses];

export type PostApiPublishByPrefixByDistributionSourcesData = {
    /**
     * Parameters
     */
    body: ApiSourceParams;
    path: {
        /**
         * publishing prefix
         */
        prefix: string;
        /**
         * distribution name
         */
        distribution: string;
    };
    query?: {
        /**
         * Run in background and return task object
         */
        _async?: boolean;
    };
    url: '/api/publish/{prefix}/{distribution}/sources';
};

export type PostApiPublishByPrefixByDistributionSourcesErrors = {
    /**
     * Bad Request
     */
    400: ApiError;
    /**
     * Published repository not found
     */
    404: ApiError;
    /**
     * Internal Error
     */
    500: ApiError;
};

export type PostApiPublishByPrefixByDistributionSourcesError = PostApiPublishByPrefixByDistributionSourcesErrors[keyof PostApiPublishByPrefixByDistributionSourcesErrors];

export type PostApiPublishByPrefixByDistributionSourcesResponses = {
    /**
     * Created
     */
    201: unknown;
};

export type PutApiPublishByPrefixByDistributionSourcesData = {
    /**
     * Parameters
     */
    body: Array<ApiSourceParams>;
    path: {
        /**
         * publishing prefix
         */
        prefix: string;
        /**
         * distribution name
         */
        distribution: string;
    };
    query?: {
        /**
         * Run in background and return task object
         */
        _async?: boolean;
    };
    url: '/api/publish/{prefix}/{distribution}/sources';
};

export type PutApiPublishByPrefixByDistributionSourcesErrors = {
    /**
     * Bad Request
     */
    400: ApiError;
    /**
     * Published repository not found
     */
    404: ApiError;
    /**
     * Internal Error
     */
    500: ApiError;
};

export type PutApiPublishByPrefixByDistributionSourcesError = PutApiPublishByPrefixByDistributionSourcesErrors[keyof PutApiPublishByPrefixByDistributionSourcesErrors];

export type PutApiPublishByPrefixByDistributionSourcesResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type DeleteApiPublishByPrefixByDistributionSourcesByComponentData = {
    body?: never;
    path: {
        /**
         * publishing prefix
         */
        prefix: string;
        /**
         * distribution name
         */
        distribution: string;
        /**
         * component name
         */
        component: string;
    };
    query?: {
        /**
         * Run in background and return task object
         */
        _async?: boolean;
    };
    url: '/api/publish/{prefix}/{distribution}/sources/{component}';
};

export type DeleteApiPublishByPrefixByDistributionSourcesByComponentErrors = {
    /**
     * Bad Request
     */
    400: ApiError;
    /**
     * Published repository not found
     */
    404: ApiError;
    /**
     * Internal Error
     */
    500: ApiError;
};

export type DeleteApiPublishByPrefixByDistributionSourcesByComponentError = DeleteApiPublishByPrefixByDistributionSourcesByComponentErrors[keyof DeleteApiPublishByPrefixByDistributionSourcesByComponentErrors];

export type DeleteApiPublishByPrefixByDistributionSourcesByComponentResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type PutApiPublishByPrefixByDistributionSourcesByComponentData = {
    /**
     * Parameters
     */
    body: ApiSourceParams;
    path: {
        /**
         * publishing prefix
         */
        prefix: string;
        /**
         * distribution name
         */
        distribution: string;
        /**
         * component name
         */
        component: string;
    };
    query?: {
        /**
         * Run in background and return task object
         */
        _async?: boolean;
    };
    url: '/api/publish/{prefix}/{distribution}/sources/{component}';
};

export type PutApiPublishByPrefixByDistributionSourcesByComponentErrors = {
    /**
     * Bad Request
     */
    400: ApiError;
    /**
     * Published repository/component not found
     */
    404: ApiError;
    /**
     * Internal Error
     */
    500: ApiError;
};

export type PutApiPublishByPrefixByDistributionSourcesByComponentError = PutApiPublishByPrefixByDistributionSourcesByComponentErrors[keyof PutApiPublishByPrefixByDistributionSourcesByComponentErrors];

export type PutApiPublishByPrefixByDistributionSourcesByComponentResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type PostApiPublishByPrefixByDistributionUpdateData = {
    /**
     * Parameters
     */
    body: ApiPublishedRepoUpdateParams;
    path: {
        /**
         * publishing prefix
         */
        prefix: string;
        /**
         * distribution name
         */
        distribution: string;
    };
    query?: {
        /**
         * Run in background and return task object
         */
        _async?: boolean;
    };
    url: '/api/publish/{prefix}/{distribution}/update';
};

export type PostApiPublishByPrefixByDistributionUpdateErrors = {
    /**
     * Bad Request
     */
    400: ApiError;
    /**
     * Published repository/component not found
     */
    404: ApiError;
    /**
     * Internal Error
     */
    500: ApiError;
};

export type PostApiPublishByPrefixByDistributionUpdateError = PostApiPublishByPrefixByDistributionUpdateErrors[keyof PostApiPublishByPrefixByDistributionUpdateErrors];

export type PostApiPublishByPrefixByDistributionUpdateResponses = {
    /**
     * OK
     */
    200: DebPublishedRepo;
};

export type PostApiPublishByPrefixByDistributionUpdateResponse = PostApiPublishByPrefixByDistributionUpdateResponses[keyof PostApiPublishByPrefixByDistributionUpdateResponses];

export type GetApiReadyData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/ready';
};

export type GetApiReadyErrors = {
    /**
     * Aptly is unavailable
     */
    503: ApiAptlyStatus;
};

export type GetApiReadyError = GetApiReadyErrors[keyof GetApiReadyErrors];

export type GetApiReadyResponses = {
    /**
     * Aptly is ready
     */
    200: ApiAptlyStatus;
};

export type GetApiReadyResponse = GetApiReadyResponses[keyof GetApiReadyResponses];

export type GetApiReposData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/repos';
};

export type GetApiReposResponses = {
    /**
     * OK
     */
    200: Array<DebLocalRepo>;
};

export type GetApiReposResponse = GetApiReposResponses[keyof GetApiReposResponses];

export type PostApiReposData = {
    /**
     * Parameters
     */
    body: ApiRepoCreateParams;
    path?: never;
    query?: never;
    url: '/api/repos';
};

export type PostApiReposErrors = {
    /**
     * Source snapshot not found
     */
    404: ApiError;
    /**
     * Local repo already exists
     */
    409: ApiError;
    /**
     * Internal error
     */
    500: ApiError;
};

export type PostApiReposError = PostApiReposErrors[keyof PostApiReposErrors];

export type PostApiReposResponses = {
    /**
     * Created
     */
    201: DebLocalRepo;
};

export type PostApiReposResponse = PostApiReposResponses[keyof PostApiReposResponses];

export type DeleteApiReposByNameData = {
    body?: never;
    path: {
        /**
         * Repository name
         */
        name: string;
    };
    query?: {
        /**
         * Run in background and return task object
         */
        _async?: boolean;
        /**
         * force: 1 to enable
         */
        force?: number;
    };
    url: '/api/repos/{name}';
};

export type DeleteApiReposByNameErrors = {
    /**
     * Repo Conflict
     */
    404: ApiError;
};

export type DeleteApiReposByNameError = DeleteApiReposByNameErrors[keyof DeleteApiReposByNameErrors];

export type DeleteApiReposByNameResponses = {
    /**
     * Repo object
     */
    200: TaskProcessReturnValue;
};

export type DeleteApiReposByNameResponse = DeleteApiReposByNameResponses[keyof DeleteApiReposByNameResponses];

export type GetApiReposByNameData = {
    body?: never;
    path: {
        /**
         * Repository name
         */
        name: string;
    };
    query?: never;
    url: '/api/repos/{name}';
};

export type GetApiReposByNameErrors = {
    /**
     * Repository not found
     */
    404: ApiError;
};

export type GetApiReposByNameError = GetApiReposByNameErrors[keyof GetApiReposByNameErrors];

export type GetApiReposByNameResponses = {
    /**
     * OK
     */
    200: DebLocalRepo;
};

export type GetApiReposByNameResponse = GetApiReposByNameResponses[keyof GetApiReposByNameResponses];

export type PutApiReposByNameData = {
    /**
     * Parameters
     */
    body: ApiReposEditParams;
    path: {
        /**
         * Repository name
         */
        name: string;
    };
    query?: never;
    url: '/api/repos/{name}';
};

export type PutApiReposByNameErrors = {
    /**
     * Not Found
     */
    404: ApiError;
    /**
     * Internal Server Error
     */
    500: ApiError;
};

export type PutApiReposByNameError = PutApiReposByNameErrors[keyof PutApiReposByNameErrors];

export type PutApiReposByNameResponses = {
    /**
     * msg
     */
    200: DebLocalRepo;
};

export type PutApiReposByNameResponse = PutApiReposByNameResponses[keyof PutApiReposByNameResponses];

export type PostApiReposByNameCopyBySrcByFileData = {
    body?: never;
    path: {
        /**
         * Destination repo
         */
        name: string;
        /**
         * Source repo
         */
        src: string;
        /**
         * File/packages to copy
         */
        file: string;
    };
    query?: {
        /**
         * Run in background and return task object
         */
        _async?: boolean;
    };
    url: '/api/repos/{name}/copy/{src}/{file}';
};

export type PostApiReposByNameCopyBySrcByFileErrors = {
    /**
     * Bad Request
     */
    400: ApiError;
    /**
     * Not Found
     */
    404: ApiError;
    /**
     * Unprocessable Entity
     */
    422: ApiError;
    /**
     * Internal Server Error
     */
    500: ApiError;
};

export type PostApiReposByNameCopyBySrcByFileError = PostApiReposByNameCopyBySrcByFileErrors[keyof PostApiReposByNameCopyBySrcByFileErrors];

export type PostApiReposByNameCopyBySrcByFileResponses = {
    /**
     * msg
     */
    200: TaskProcessReturnValue;
};

export type PostApiReposByNameCopyBySrcByFileResponse = PostApiReposByNameCopyBySrcByFileResponses[keyof PostApiReposByNameCopyBySrcByFileResponses];

export type PostApiReposByNameFileByDirData = {
    body?: never;
    path: {
        /**
         * Repository name
         */
        name: string;
        /**
         * Directory to add
         */
        dir: string;
    };
    query?: {
        /**
         * when value is set to 1, don’t remove any files
         */
        noRemove?: string;
        /**
         * when value is set to 1, remove packages conflicting with package being added (in local repository)
         */
        forceReplace?: string;
        /**
         * Run in background and return task object
         */
        _async?: boolean;
    };
    url: '/api/repos/{name}/file/{dir}';
};

export type PostApiReposByNameFileByDirErrors = {
    /**
     * wrong file
     */
    400: ApiError;
    /**
     * Repository not found
     */
    404: ApiError;
    /**
     * Error adding files
     */
    500: ApiError;
};

export type PostApiReposByNameFileByDirError = PostApiReposByNameFileByDirErrors[keyof PostApiReposByNameFileByDirErrors];

export type PostApiReposByNameFileByDirResponses = {
    /**
     * OK
     */
    200: string;
};

export type PostApiReposByNameFileByDirResponse = PostApiReposByNameFileByDirResponses[keyof PostApiReposByNameFileByDirResponses];

export type PostApiReposByNameFileByDirByFileData = {
    body?: never;
    path: {
        /**
         * Repository name
         */
        name: string;
        /**
         * Directory of packages
         */
        dir: string;
        /**
         * Filename (optional)
         */
        file?: string;
    };
    query?: {
        /**
         * Run in background and return task object
         */
        _async?: boolean;
    };
    url: '/api/repos/{name}/file/{dir}/{file}';
};

export type PostApiReposByNameFileByDirByFileErrors = {
    /**
     * wrong file
     */
    400: ApiError;
    /**
     * Repository not found
     */
    404: ApiError;
    /**
     * Error adding files
     */
    500: ApiError;
};

export type PostApiReposByNameFileByDirByFileError = PostApiReposByNameFileByDirByFileErrors[keyof PostApiReposByNameFileByDirByFileErrors];

export type PostApiReposByNameFileByDirByFileResponses = {
    /**
     * OK
     */
    200: string;
};

export type PostApiReposByNameFileByDirByFileResponse = PostApiReposByNameFileByDirByFileResponses[keyof PostApiReposByNameFileByDirByFileResponses];

export type PostApiReposByNameIncludeByDirData = {
    body?: never;
    path: {
        /**
         * Repository name
         */
        name: string;
        /**
         * Directory of packages
         */
        dir: string;
    };
    query?: {
        /**
         * when value is set to 1, when adding package that conflicts with existing package, remove existing package
         */
        forceReplace?: number;
        /**
         * when value is set to 1, don’t remove files that have been imported successfully into repository
         */
        noRemoveFiles?: number;
        /**
         * when value is set to 1, accept unsigned .changes files
         */
        acceptUnsigned?: number;
        /**
         * when value is set to 1 disable verification of .changes file signature
         */
        ignoreSignature?: number;
        /**
         * Run in background and return task object
         */
        _async?: boolean;
    };
    url: '/api/repos/{name}/include/{dir}';
};

export type PostApiReposByNameIncludeByDirErrors = {
    /**
     * Not Found
     */
    404: ApiError;
};

export type PostApiReposByNameIncludeByDirError = PostApiReposByNameIncludeByDirErrors[keyof PostApiReposByNameIncludeByDirErrors];

export type PostApiReposByNameIncludeByDirResponses = {
    /**
     * Response
     */
    200: ApiReposIncludePackageFromDirResponse;
};

export type PostApiReposByNameIncludeByDirResponse = PostApiReposByNameIncludeByDirResponses[keyof PostApiReposByNameIncludeByDirResponses];

export type PostApiReposByNameIncludeByDirByFileData = {
    body?: never;
    path: {
        /**
         * Repository name
         */
        name: string;
        /**
         * Directory of packages
         */
        dir: string;
        /**
         * File/packages to include
         */
        file: string;
    };
    query?: {
        /**
         * when value is set to 1, when adding package that conflicts with existing package, remove existing package
         */
        forceReplace?: number;
        /**
         * when value is set to 1, don’t remove files that have been imported successfully into repository
         */
        noRemoveFiles?: number;
        /**
         * when value is set to 1, accept unsigned .changes files
         */
        acceptUnsigned?: number;
        /**
         * when value is set to 1 disable verification of .changes file signature
         */
        ignoreSignature?: number;
        /**
         * Run in background and return task object
         */
        _async?: boolean;
    };
    url: '/api/repos/{name}/include/{dir}/{file}';
};

export type PostApiReposByNameIncludeByDirByFileErrors = {
    /**
     * Not Found
     */
    404: ApiError;
};

export type PostApiReposByNameIncludeByDirByFileError = PostApiReposByNameIncludeByDirByFileErrors[keyof PostApiReposByNameIncludeByDirByFileErrors];

export type PostApiReposByNameIncludeByDirByFileResponses = {
    /**
     * msg
     */
    200: string;
};

export type PostApiReposByNameIncludeByDirByFileResponse = PostApiReposByNameIncludeByDirByFileResponses[keyof PostApiReposByNameIncludeByDirByFileResponses];

export type DeleteApiReposByNamePackagesData = {
    /**
     * Parameters
     */
    body: ApiReposPackagesAddDeleteParams;
    path: {
        /**
         * Repository name
         */
        name: string;
    };
    query?: {
        /**
         * Run in background and return task object
         */
        _async?: boolean;
    };
    url: '/api/repos/{name}/packages';
};

export type DeleteApiReposByNamePackagesErrors = {
    /**
     * Internal Server Error
     */
    400: ApiError;
    /**
     * Not Found
     */
    404: ApiError;
};

export type DeleteApiReposByNamePackagesError = DeleteApiReposByNamePackagesErrors[keyof DeleteApiReposByNamePackagesErrors];

export type DeleteApiReposByNamePackagesResponses = {
    /**
     * msg
     */
    200: string;
};

export type DeleteApiReposByNamePackagesResponse = DeleteApiReposByNamePackagesResponses[keyof DeleteApiReposByNamePackagesResponses];

export type GetApiReposByNamePackagesData = {
    body?: never;
    path: {
        /**
         * Repository name
         */
        name: string;
    };
    query: {
        /**
         * Package query (e.g Name%20(~%20matlab))
         */
        q: string;
        /**
         * Set to 1 to include dependencies when evaluating package query
         */
        withDeps: string;
        /**
         * Set to 'details' to return extra info about each package
         */
        format: string;
        /**
         * Set to 1 to only return the highest version for each package name
         */
        maximumVersion: string;
    };
    url: '/api/repos/{name}/packages';
};

export type GetApiReposByNamePackagesErrors = {
    /**
     * Internal Server Error
     */
    404: ApiError;
};

export type GetApiReposByNamePackagesError = GetApiReposByNamePackagesErrors[keyof GetApiReposByNamePackagesErrors];

export type GetApiReposByNamePackagesResponses = {
    /**
     * msg
     */
    200: string;
};

export type GetApiReposByNamePackagesResponse = GetApiReposByNamePackagesResponses[keyof GetApiReposByNamePackagesResponses];

export type PostApiReposByNamePackagesData = {
    /**
     * Parameters
     */
    body: ApiReposPackagesAddDeleteParams;
    path: {
        /**
         * Repository name
         */
        name: string;
    };
    query?: {
        /**
         * Run in background and return task object
         */
        _async?: boolean;
    };
    url: '/api/repos/{name}/packages';
};

export type PostApiReposByNamePackagesErrors = {
    /**
     * Internal Server Error
     */
    400: ApiError;
    /**
     * Not Found
     */
    404: ApiError;
};

export type PostApiReposByNamePackagesError = PostApiReposByNamePackagesErrors[keyof PostApiReposByNamePackagesErrors];

export type PostApiReposByNamePackagesResponses = {
    /**
     * msg
     */
    200: string;
};

export type PostApiReposByNamePackagesResponse = PostApiReposByNamePackagesResponses[keyof PostApiReposByNamePackagesResponses];

export type PostApiReposByNameSnapshotsData = {
    /**
     * Parameters
     */
    body: ApiSnapshotsCreateFromRepositoryParams;
    path: {
        /**
         * Name of the snapshot
         */
        name: string;
    };
    query?: {
        /**
         * Run in background and return task object
         */
        _async?: boolean;
    };
    url: '/api/repos/{name}/snapshots';
};

export type PostApiReposByNameSnapshotsErrors = {
    /**
     * Bad Request
     */
    400: ApiError;
    /**
     * Repo Not Found
     */
    404: ApiError;
    /**
     * Internal Server Error
     */
    500: ApiError;
};

export type PostApiReposByNameSnapshotsError = PostApiReposByNameSnapshotsErrors[keyof PostApiReposByNameSnapshotsErrors];

export type PostApiReposByNameSnapshotsResponses = {
    /**
     * Created snapshot object
     */
    201: DebSnapshot;
};

export type PostApiReposByNameSnapshotsResponse = PostApiReposByNameSnapshotsResponses[keyof PostApiReposByNameSnapshotsResponses];

export type GetApiS3Data = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/s3';
};

export type GetApiS3Responses = {
    /**
     * List of S3 buckets
     */
    200: Array<string>;
};

export type GetApiS3Response = GetApiS3Responses[keyof GetApiS3Responses];

export type GetApiSnapshotsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/snapshots';
};

export type GetApiSnapshotsResponses = {
    /**
     * OK
     */
    200: Array<DebSnapshot>;
};

export type GetApiSnapshotsResponse = GetApiSnapshotsResponses[keyof GetApiSnapshotsResponses];

export type PostApiSnapshotsData = {
    /**
     * Parameters
     */
    body: ApiSnapshotsCreateParams;
    path?: never;
    query?: {
        /**
         * Run in background and return task object
         */
        _async?: boolean;
    };
    url: '/api/snapshots';
};

export type PostApiSnapshotsErrors = {
    /**
     * Bad Request
     */
    400: ApiError;
    /**
     * Source snapshot or package refs not found
     */
    404: ApiError;
    /**
     * Internal Server Error
     */
    500: ApiError;
};

export type PostApiSnapshotsError = PostApiSnapshotsErrors[keyof PostApiSnapshotsErrors];

export type PostApiSnapshotsResponses = {
    /**
     * Created snapshot
     */
    201: DebSnapshot;
};

export type PostApiSnapshotsResponse = PostApiSnapshotsResponses[keyof PostApiSnapshotsResponses];

export type DeleteApiSnapshotsByNameData = {
    body?: never;
    path: {
        /**
         * Snapshot name
         */
        name: string;
    };
    query?: {
        /**
         * Force operation
         */
        force?: string;
        /**
         * Run in background and return task object
         */
        _async?: boolean;
    };
    url: '/api/snapshots/{name}';
};

export type DeleteApiSnapshotsByNameErrors = {
    /**
     * Snapshot Not Found
     */
    404: ApiError;
    /**
     * Snapshot in use
     */
    409: ApiError;
    /**
     * Internal Server Error
     */
    500: ApiError;
};

export type DeleteApiSnapshotsByNameError = DeleteApiSnapshotsByNameErrors[keyof DeleteApiSnapshotsByNameErrors];

export type DeleteApiSnapshotsByNameResponses = {
    200: unknown;
};

export type GetApiSnapshotsByNameData = {
    body?: never;
    path: {
        /**
         * Name of the snapshot
         */
        name: string;
    };
    query?: never;
    url: '/api/snapshots/{name}';
};

export type GetApiSnapshotsByNameErrors = {
    /**
     * Snapshot Not Found
     */
    404: ApiError;
    /**
     * Internal Server Error
     */
    500: ApiError;
};

export type GetApiSnapshotsByNameError = GetApiSnapshotsByNameErrors[keyof GetApiSnapshotsByNameErrors];

export type GetApiSnapshotsByNameResponses = {
    /**
     * msg
     */
    200: DebSnapshot;
};

export type GetApiSnapshotsByNameResponse = GetApiSnapshotsByNameResponses[keyof GetApiSnapshotsByNameResponses];

export type PutApiSnapshotsByNameData = {
    /**
     * Parameters
     */
    body: ApiSnapshotsUpdateParams;
    path: {
        /**
         * Snapshot name
         */
        name: string;
    };
    query?: {
        /**
         * Run in background and return task object
         */
        _async?: boolean;
    };
    url: '/api/snapshots/{name}';
};

export type PutApiSnapshotsByNameErrors = {
    /**
     * Snapshot Not Found
     */
    404: ApiError;
    /**
     * Conflicting snapshot
     */
    409: ApiError;
    /**
     * Internal Server Error
     */
    500: ApiError;
};

export type PutApiSnapshotsByNameError = PutApiSnapshotsByNameErrors[keyof PutApiSnapshotsByNameErrors];

export type PutApiSnapshotsByNameResponses = {
    /**
     * Updated snapshot object
     */
    200: DebSnapshot;
};

export type PutApiSnapshotsByNameResponse = PutApiSnapshotsByNameResponses[keyof PutApiSnapshotsByNameResponses];

export type GetApiSnapshotsByNameDiffByWithSnapshotData = {
    body?: never;
    path: {
        /**
         * Snapshot name
         */
        name: string;
        /**
         * Snapshot name to diff against
         */
        withSnapshot: string;
    };
    query?: {
        /**
         * Only return packages present in both snapshots
         */
        onlyMatching?: string;
    };
    url: '/api/snapshots/{name}/diff/{withSnapshot}';
};

export type GetApiSnapshotsByNameDiffByWithSnapshotErrors = {
    /**
     * Snapshot Not Found
     */
    404: ApiError;
    /**
     * Internal Server Error
     */
    500: ApiError;
};

export type GetApiSnapshotsByNameDiffByWithSnapshotError = GetApiSnapshotsByNameDiffByWithSnapshotErrors[keyof GetApiSnapshotsByNameDiffByWithSnapshotErrors];

export type GetApiSnapshotsByNameDiffByWithSnapshotResponses = {
    /**
     * Package Diff
     */
    200: Array<DebPackageDiff>;
};

export type GetApiSnapshotsByNameDiffByWithSnapshotResponse = GetApiSnapshotsByNameDiffByWithSnapshotResponses[keyof GetApiSnapshotsByNameDiffByWithSnapshotResponses];

export type PostApiSnapshotsByNameMergeData = {
    /**
     * Parameters
     */
    body: ApiSnapshotsMergeParams;
    path: {
        /**
         * Name of the snapshot to be created
         */
        name: string;
    };
    query?: {
        /**
         * merge only the latest version of each package
         */
        latest?: number;
        /**
         * all versions of packages are preserved during merge
         */
        'no-remove'?: number;
        /**
         * Run in background and return task object
         */
        _async?: boolean;
    };
    url: '/api/snapshots/{name}/merge';
};

export type PostApiSnapshotsByNameMergeErrors = {
    /**
     * Bad Request
     */
    400: ApiError;
    /**
     * Not Found
     */
    404: ApiError;
    /**
     * Internal Error
     */
    500: ApiError;
};

export type PostApiSnapshotsByNameMergeError = PostApiSnapshotsByNameMergeErrors[keyof PostApiSnapshotsByNameMergeErrors];

export type PostApiSnapshotsByNameMergeResponses = {
    /**
     * Resulting snapshot object
     */
    201: DebSnapshot;
};

export type PostApiSnapshotsByNameMergeResponse = PostApiSnapshotsByNameMergeResponses[keyof PostApiSnapshotsByNameMergeResponses];

export type GetApiSnapshotsByNamePackagesData = {
    body?: never;
    path: {
        /**
         * Snapshot to search
         */
        name: string;
    };
    query?: {
        /**
         * Package query (e.g Name%20(~%20matlab))
         */
        q?: string;
        /**
         * Set to 1 to include dependencies when evaluating package query
         */
        withDeps?: string;
        /**
         * Set to 'details' to return extra info about each package
         */
        format?: string;
        /**
         * Set to 1 to only return the highest version for each package name
         */
        maximumVersion?: string;
    };
    url: '/api/snapshots/{name}/packages';
};

export type GetApiSnapshotsByNamePackagesErrors = {
    /**
     * Snapshot Not Found
     */
    404: ApiError;
    /**
     * Internal Server Error
     */
    500: ApiError;
};

export type GetApiSnapshotsByNamePackagesError = GetApiSnapshotsByNamePackagesErrors[keyof GetApiSnapshotsByNamePackagesErrors];

export type GetApiSnapshotsByNamePackagesResponses = {
    /**
     * Package info
     */
    200: Array<string>;
};

export type GetApiSnapshotsByNamePackagesResponse = GetApiSnapshotsByNamePackagesResponses[keyof GetApiSnapshotsByNamePackagesResponses];

export type PostApiSnapshotsByNamePullData = {
    /**
     * Parameters
     */
    body: ApiSnapshotsPullParams;
    path: {
        /**
         * Name of the snapshot to be created
         */
        name: string;
    };
    query?: {
        /**
         * pull all the packages that satisfy the dependency version requirements (default is to pull first matching package): 1 to enable
         */
        'all-matches'?: number;
        /**
         * don’t create destination snapshot, just show what would be pulled: 1 to enable
         */
        'dry-run'?: number;
        /**
         * don’t process dependencies, just pull listed packages: 1 to enable
         */
        'no-deps'?: number;
        /**
         * don’t remove other package versions when pulling package: 1 to enable
         */
        'no-remove'?: number;
        /**
         * Run in background and return task object
         */
        _async?: boolean;
    };
    url: '/api/snapshots/{name}/pull';
};

export type PostApiSnapshotsByNamePullErrors = {
    /**
     * Bad Request
     */
    400: ApiError;
    /**
     * Not Found
     */
    404: ApiError;
    /**
     * Internal Error
     */
    500: ApiError;
};

export type PostApiSnapshotsByNamePullError = PostApiSnapshotsByNamePullErrors[keyof PostApiSnapshotsByNamePullErrors];

export type PostApiSnapshotsByNamePullResponses = {
    /**
     * Resulting Snapshot object
     */
    200: DebSnapshot;
};

export type PostApiSnapshotsByNamePullResponse = PostApiSnapshotsByNamePullResponses[keyof PostApiSnapshotsByNamePullResponses];

export type GetApiStorageData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/storage';
};

export type GetApiStorageErrors = {
    /**
     * Internal Error
     */
    400: ApiError;
};

export type GetApiStorageError = GetApiStorageErrors[keyof GetApiStorageErrors];

export type GetApiStorageResponses = {
    /**
     * Storage information
     */
    200: ApiDiskFree;
};

export type GetApiStorageResponse = GetApiStorageResponses[keyof GetApiStorageResponses];

export type GetApiTasksData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/tasks';
};

export type GetApiTasksResponses = {
    /**
     * OK
     */
    200: Array<TaskTask>;
};

export type GetApiTasksResponse = GetApiTasksResponses[keyof GetApiTasksResponses];

export type PostApiTasksClearData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/tasks-clear';
};

export type PostApiTasksClearResponses = {
    200: unknown;
};

export type GetApiTasksWaitData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/tasks-wait';
};

export type GetApiTasksWaitResponses = {
    200: unknown;
};

export type DeleteApiTasksByIdData = {
    body?: never;
    path: {
        /**
         * Task ID
         */
        id: number;
    };
    query?: never;
    url: '/api/tasks/{id}';
};

export type DeleteApiTasksByIdErrors = {
    /**
     * Task in progress or not found
     */
    400: ApiError;
    /**
     * invalid syntax, bad ID?
     */
    500: ApiError;
};

export type DeleteApiTasksByIdError = DeleteApiTasksByIdErrors[keyof DeleteApiTasksByIdErrors];

export type DeleteApiTasksByIdResponses = {
    /**
     * OK
     */
    200: TaskTask;
};

export type DeleteApiTasksByIdResponse = DeleteApiTasksByIdResponses[keyof DeleteApiTasksByIdResponses];

export type GetApiTasksByIdData = {
    body?: never;
    path: {
        /**
         * Task ID
         */
        id: number;
    };
    query?: never;
    url: '/api/tasks/{id}';
};

export type GetApiTasksByIdErrors = {
    /**
     * Task Not Found
     */
    404: ApiError;
    /**
     * invalid syntax, bad id?
     */
    500: ApiError;
};

export type GetApiTasksByIdError = GetApiTasksByIdErrors[keyof GetApiTasksByIdErrors];

export type GetApiTasksByIdResponses = {
    /**
     * OK
     */
    200: TaskTask;
};

export type GetApiTasksByIdResponse = GetApiTasksByIdResponses[keyof GetApiTasksByIdResponses];

export type GetApiTasksByIdDetailData = {
    body?: never;
    path: {
        /**
         * Task ID
         */
        id: number;
    };
    query?: never;
    url: '/api/tasks/{id}/detail';
};

export type GetApiTasksByIdDetailErrors = {
    /**
     * Task Not Found
     */
    404: ApiError;
    /**
     * invalid syntax, bad ID?
     */
    500: ApiError;
};

export type GetApiTasksByIdDetailError = GetApiTasksByIdDetailErrors[keyof GetApiTasksByIdDetailErrors];

export type GetApiTasksByIdDetailResponses = {
    /**
     * Task detail
     */
    200: string;
};

export type GetApiTasksByIdDetailResponse = GetApiTasksByIdDetailResponses[keyof GetApiTasksByIdDetailResponses];

export type GetApiTasksByIdOutputData = {
    body?: never;
    path: {
        /**
         * Task ID
         */
        id: number;
    };
    query?: never;
    url: '/api/tasks/{id}/output';
};

export type GetApiTasksByIdOutputErrors = {
    /**
     * Task Not Found
     */
    404: ApiError;
    /**
     * invalid syntax, bad ID?
     */
    500: ApiError;
};

export type GetApiTasksByIdOutputError = GetApiTasksByIdOutputErrors[keyof GetApiTasksByIdOutputErrors];

export type GetApiTasksByIdOutputResponses = {
    /**
     * Task output
     */
    200: string;
};

export type GetApiTasksByIdOutputResponse = GetApiTasksByIdOutputResponses[keyof GetApiTasksByIdOutputResponses];

export type GetApiTasksByIdReturnValueData = {
    body?: never;
    path: {
        /**
         * Task ID
         */
        id: number;
    };
    query?: never;
    url: '/api/tasks/{id}/return_value';
};

export type GetApiTasksByIdReturnValueErrors = {
    /**
     * Not Found
     */
    404: ApiError;
    /**
     * invalid syntax, bad ID?
     */
    500: ApiError;
};

export type GetApiTasksByIdReturnValueError = GetApiTasksByIdReturnValueErrors[keyof GetApiTasksByIdReturnValueErrors];

export type GetApiTasksByIdReturnValueResponses = {
    /**
     * msg
     */
    200: string;
};

export type GetApiTasksByIdReturnValueResponse = GetApiTasksByIdReturnValueResponses[keyof GetApiTasksByIdReturnValueResponses];

export type GetApiTasksByIdWaitData = {
    body?: never;
    path: {
        /**
         * Task ID
         */
        id: number;
    };
    query?: never;
    url: '/api/tasks/{id}/wait';
};

export type GetApiTasksByIdWaitErrors = {
    /**
     * Task Not Found
     */
    400: ApiError;
    /**
     * invalid syntax, bad id?
     */
    500: ApiError;
};

export type GetApiTasksByIdWaitError = GetApiTasksByIdWaitErrors[keyof GetApiTasksByIdWaitErrors];

export type GetApiTasksByIdWaitResponses = {
    /**
     * OK
     */
    200: TaskTask;
};

export type GetApiTasksByIdWaitResponse = GetApiTasksByIdWaitResponses[keyof GetApiTasksByIdWaitResponses];

export type GetApiVersionData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/version';
};

export type GetApiVersionResponses = {
    /**
     * OK
     */
    200: ApiAptlyVersion;
};

export type GetApiVersionResponse = GetApiVersionResponses[keyof GetApiVersionResponses];

export type GetApiByStorageByPkgPathData = {
    body?: never;
    path: {
        /**
         * Storage
         */
        storage: string;
        /**
         * Package Path
         */
        pkgPath: string;
    };
    query?: never;
    url: '/api/{storage}/{pkgPath}';
};

export type GetApiByStorageByPkgPathResponses = {
    200: unknown;
};
